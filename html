<!-- public/index.html -->
<tbody></tbody>
</table>
</div>
</div>
</div>
</div>


<script>
/* Frontend calls /api/prices on same origin. The server caches and returns compact data. */
const chartCtx = document.getElementById('chart').getContext('2d');
let chart = new Chart(chartCtx, {type:'line',data:{labels:[],datasets:[{label:'',data:[],borderColor:'#6ee7b7',borderWidth:2,tension:0.25,pointRadius:0}]},options:{responsive:true,maintainAspectRatio:false,scales:{x:{display:false}}}});


async function fetchServerPrices(assets, vs='USD'){
try{
const q = encodeURIComponent(assets.join(','));
const res = await fetch(`/api/prices?assets=${q}&vs=${encodeURIComponent(vs)}`);
if(!res.ok) throw new Error('server '+res.status);
return await res.json();
}catch(e){ console.error('server fetch err', e); return null; }
}


function storageKey(a){ return 'sr_vfinal_'+a.replace('/','_'); }
function loadSeries(a){ try{return JSON.parse(localStorage.getItem(storageKey(a))||'[]');}catch(e){return[];} }
function saveSeries(a,s){ localStorage.setItem(storageKey(a), JSON.stringify(s.slice(-600))); }


async function gather(){
document.getElementById('status').textContent = 'fetching';
const vs = document.getElementById('viewCurrency').value || 'USD';
const checked = Array.from(document.querySelectorAll('.assetChk:checked')).map(i=>i.value);
const q = document.getElementById('searchBox').value.trim();
if(q) checked.unshift(q);
if(!checked.length) return;
const data = await fetchServerPrices(checked, vs);
if(!data){ document.getElementById('status').textContent = 'server error'; return; }


const rows = [];
for(const a of Object.keys(data)){
const d = data[a];
// d: { price, change24h?, type }
const price = d.price;
const s = loadSeries(a);
s.push({t:Date.now(), price});
saveSeries(a,s);
// compute simple rec on client quickly using series
const rec = computeRecFromSeries(s);
rows.push({asset:a, priceDisplay: d.display || price, price, change24h:d.change24h, score:rec.score, rec:rec.rec, why:rec.why, type:d.type});
}


renderTable(rows);
renderTracked(rows);
document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
document.getElementById('status').textContent = 'ok';


// update chart for first
const first = rows.find(r=>r.price!==undefined && r.price!==null);
if(first){ const s = loadSeries(first.asset); chart.data.labels = s.map(x=>new Date(x.t).toLocaleTimeString()); chart.data.datasets[0].label = first.asset; chart.data.datasets[0].data = s.map(x=>x.price); chart.update(); }
}


function computeRecFromSeries(series){
const prices = series.map(s=>s.price);
if(prices.length<30) return {score:null, rec:'HOLD', why:'not enough data'};
// same logic as server could be applied, but keep it light
const ema9 = ema(prices,9), ema21 = ema(prices,21);
const r = rsi(prices,14);
const score = Math.round(50 + (ema9-ema21) / (Math.abs(ema21)||1) * 200);
let rec='HOLD'; if(score>=60) rec='BUY'; else if(score<=40) rec='SELL';
return {score,rec,why:`EMA9:${ema9?ema9.toFixed(6):'n/a'} RSI:${r?r.toFixed(1):'n/a'}`};
}
function ema(arr,period){ if(!arr.leng
